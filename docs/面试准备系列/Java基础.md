[TOC]



## 初识JAVA

#### JVM、JDK、JRE的关系

JVM：Java Virtual Machine ,Java 虚拟机，因为有了JVM 的存在，才能让Java运行在不同的平台上。

JDK：Java Development Kit,包含Java 编译环境和运行环境

JRE: Java Runtime Environment,编译好的java代码需要在jre上运行，如果只是想运行程序而不做更改，那么只需要安装jar就可以了

#### 什么是跨平台，原理是什么

Java 代码可以一次编译，在不同的平台多次运行

原理：只要安装了对应的Java 虚拟机，就能运行程序

#### Java的特点

继承，多态，封装

#### 什么是字节码？采用自己码最大的好处是什么？

Java 编译后的文件 xxx.class 就是字节码文件

好处：可以通过字节码将java 程序在不同的虚拟机上运行

#### Java和C++的区别

- 都是面向对象的语言，都支持封装、继承和多态
- Java不提供指针来直接访问内存，程序内存更加安全
- Java的类是单继承的，C++支持多重继承；虽然Java的类不可以多继承，但是接口可以多继承。
- Java有自动内存管理机制，不需要程序员手动释放无用内存

## 基础语法

### 数据类型

#### Java的基本数据类型有哪些

byte,short,int,long,float,double,char,boolean

#### switch能否作用在byte上，能否作用在long上，能否作用在String上

在Java5 之前swtich(expr) 只能作用在byte，short ,char,int上；

在java5 之后加入了枚举类型，expr 可以是enum类型

从java7 之后可以是String 类型

long类型一直不支持

#### 用最有效率的方法计算2乘以8

2<<3 左移3位

#### Math.round(11.5)等于多少？Math.roun(-11.5)等于多少？

前者12，后者-11，可以画一个数轴，自行理解，round是向右取整

#### float f = 3.4 是否正确？

不正确，3.4是double类型的，如果要是转换成float需要强制转换，或者写成3.4f

#### short s1 = 1;s1 = s1 +1;正确吗？short s1 = 1;s1+=1,正确吗？

前者不正确，short 类型计算的时候会自动转换成int 类型的数据，返回值是int 类型的。后者正确，内部会自动将结果在转换成short类型的

### 编码

#### Java采用何种编码方案，有何特点？

Unicode

它为每个字符制订了一个唯一的数值，因此在任何的语言，平台，程序都可以放心的使用。

### 注释

#### 什么是Java注释？

用于解释程序说明的文字

### 访问修饰符

#### 4种访问修饰符的区别

private 

protected

默认的

public

![img](https://mmbiz.qpic.cn/mmbiz_png/rAMaszgAyWpblibxHNficQAaicBURw5uxaYHH3PwsT3uv5eYw341sEcibLqQMdVtchPRnmmSGAuXKWZyGTlzhvibozA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

### 运算符

#### &和&&的区别

&是按位与

&&是逻辑与

### 关键字

#### Java有没有goto

goto 作为了保留关键字，目前没有使用

#### final有什么用

final 修饰的类不能被继承

final 修饰的方法不能被重写

final 修饰的变量是常量，不能被修改

#### final finally finalize 的区别

final 是修饰类，方法，变量的

finally 是异常机制中的，在异常中一定会执行

finalize是一个方法，属于Object类的一个方法，而Object类是所有类的父类，该方法一般由垃圾回收器来调
用，当我们调用System.gc() 方法的时候，由垃圾回收器调用finalize()，回收垃圾，一个对象是否可回收的
最后判断。

#### this关键字的用法

this 代表的就是对象本身，可以理解为一直指向当前对象的一个指针，this可以调用同类的构造方法，直接this.属性

#### super关键字的用法

super 指向的是父类的对象的引用，super可以调用父类的构造方法，super.属性调用父类的属性

#### static存在的主要意义

static 修饰的代码块是静态代码块，可以以此来优化程序的性能，因为只需要执行一次; static 加载的时候还没有创建对象，亦可以调用。

#### static的独特之处

- static 修饰的方法和变量不是对象独有的，所有此类的对象都可以共同使用
- static 在类第一次被加载的时候就需要初始化
- static 变量值在类加载的时候分配空间，之后不修改空间，但是可以修改变量值
- static 的初始化早于对象，即使不创建对象也能访问

#### static 应用场景

- 成员变量
- 成员方法
- 静态代码块
- 静态内部类
- 静态导包

#### static 注意事项

静态只能访问静态方法，非静态可以访问静态或者非静态的

### 流程控制语句

#### break,continue,return 的区别和作用

break : 结束本次循环

continue: 结束当前正在执行的循环，跳转到下次循环

return : 结束当前方法，直接返回

#### 在Java中，如何跳出当前的多重嵌套循环

使用带有标号的break语句

## 面向对象

### 面向对象概述

#### 面向对象和面向过程的区别

面向过程解决问题要从前向后，一步一步的解决下去

面向对象是抽象出一个类，可以更好的解决耦合的问题，但是底层还是通过面向过程实现的。

### 面向对象的三大特性

封装，继承，多态

#### 面向对象的特征有哪些方面

#### 什么多态机制？Java语言是如何实现多态的？

多态机制就是一个程序在编程的时候不能确定调用哪个方法，只有在程序运行的时候才能知道具体需要的类。

多态分为编译时多态和运行时多态。重载就是编译时多态，重写可以理解成运行时多态。

Java 实现多态的条件：继承，重写，向上转型

#### 面向对象的五大基本原则是什么

单一职责原则SRP(Single Responsibility Principle)
类的功能要单一，不能包罗万象，跟杂货铺似的。
开放封闭原则OCP(Open－Close Principle)
一个模块对于拓展是开放的，对于修改是封闭的，想要增加功能热烈欢迎，想要修改，哼，一万个不乐意。
里式替换原则LSP(the Liskov Substitution Principle LSP)
子类可以替换父类出现在父类能够出现的任何地方。比如你能代表你爸去你姥姥家干活。哈哈~~
依赖倒置原则DIP(the Dependency Inversion Principle DIP)
高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象。抽象不应该依赖于具体实现，具体实现应该依赖于抽象。就是你出国要说你是中国人，而不能说你是哪个村子的。比如说中国人是抽象的，下面有具体的xx省，xx市，xx县。你要依赖的抽象是中国人，而不是你是xx村的。
接口分离原则ISP(the Interface Segregation Principle ISP)
设计时采用多个与特定客户类有关的接口比采用一个通用的接口要好。就比如一个手机拥有打电话，看视频，玩游戏等功能，把这几个功能拆分成不同的接口，比在一个接口里要好的多。
————————————————
版权声明：本文为CSDN博主「ThinkWon」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/ThinkWon/article/details/104390612

### 类与接口

#### 抽象类和接口的对比

抽象类是用来捕捉子类的通用特性的。接口是抽象方法的集合。

从设计层面来说，抽象类是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。

相同点

接口和抽象类都不能实例化
都位于继承的顶端，用于被其他实现或继承
都包含抽象方法，其子类都必须覆写这些抽象方法
不同点

| 参数       | 抽象类                                                       | 接口                                                         |
| ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 声明       | 使用abstract关键字声明                                       | 使用interface关键字声明                                      |
| 实现       | 子类使用extends关键字继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现 | 子类使用implements关键字实现接口，需要提供接口中所有声明方法的实现 |
| 构造器     | 抽象类可以有构造器                                           | 接口不能有构造器                                             |
| 访问修饰符 | 抽象类中的方法可以是任意访问修饰符                           | 接口方法默认修饰符是pulibc,并且不能定义成pricate或者protected |
| 多继承     | 最多继承一个抽象类                                           | 可以实现多个接口                                             |
| 字段声明   | 任意                                                         | static final                                                 |


备注：Java8中接口中引入默认方法和静态方法，以此来减少抽象类和接口之间的差异。

现在，我们可以为接口提供默认实现的方法了，并且不用强制子类来实现它。

接口和抽象类各有优缺点，在接口和抽象类的选择上，必须遵守这样一个原则：

行为模型应该总是通过接口而不是抽象类定义，所以通常是优先选用接口，尽量少用抽象类。
选择抽象类的时候通常是如下情况：需要定义子类的行为，又要为子类提供通用的功能。
————————————————
版权声明：本文为CSDN博主「ThinkWon」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/ThinkWon/article/details/104390612

#### 普通类和抽象类有哪些区别

- 普通类不能包含抽象方法，抽象类可以包含抽象方法
- 抽象类不能直接实例化，普通类可以直接实例化

#### 抽象类能使用final 修饰吗

不能，抽象类就是为了让其他继承的，如果定义成fina就不能别继承，出现了冲突

#### 创建一个对象用什么关键字？对象实例与对象引用有何不同？

new 关键字

new 创建对象实例（堆内存），对象应用指向对象实例（栈内存），一个对象引用可以指向0或1个对象，一个对象可以有n 个引用指向它

### 变量与方法

#### 成员变量与局部变量的区别有哪些

| 参数     | 成员变量                 | 局部变量                                                     |
| -------- | ------------------------ | ------------------------------------------------------------ |
| 作用域   | 针对整个类有效           | 针对局部有效                                                 |
| 存储位置 | 存在堆内存中             | 在方法被调用或语句被执行的时候，存在栈内存中，方法调用接结束或语句执行结束后，自动释放 |
| 生命周期 | 随着对象的创建存在或消失 | 在方法被调用或语句被执行的时候创建，方法调用接结束或语句执行结束后，自动释放 |
| 初始值   | 有默认的初始值           | 没有默认的初始值                                             |



#### 在Java中定义一个不做事且没有参数的构造方法的作用

在子类中，如果写了super() 调用父类的构造方法，程序可以正常编译；如果子类中没调用super() 父类的构造方法，不存在无参的构造方法的时候，会编译失败，加上这个构造方法后，子类调用的时候会默认调用父类的这个构造方法。

#### 在调用子类构造方法之前会先调用父类没有参数的构造方法，目的是什么

帮助子类初始化

#### 一个类的构造方法的作用是什么，若一个类没有声明构造方法，改程序能正确执行吗

初始化参数，可以正常运行，会默认调用无参的构造方法

#### 构造方法有哪些特性

与类名相同，没有返回值类型，不能使用void 

#### 静态变量和实例变量的区别

静态变量在类加载的时候JVM会分配一次内存空间，只有一份

实例变量在对象创建的时候分配内存空间，每个对象都会有一份

#### 静态变量和普通变量的区别

静态变量是类独有的，在类加载的时候JVM 会分配内存空间，只会有一份；

普通变量是对象拥有的，在创建对象的时候会被初始化，有多个副本，且相互之间不影响

#### 静态方法和实例方法的不同之处

- 外部方法访问：静态方法访问的时候可以类名.方法或者对象.方法；实例方法只能对象.方法
- 静态方法访问本类的成员，只能访问静态的，实例方法则都可以访问

#### 在一个静态方法内调用一个非静态成员为什么是非法的

静态方法是类加载时创建的，不属于某个对象，而实例成员在创建对象的时候才会存在，所以不能调用。

#### 什么是方法的返回值，返回值的作用是什么

将方法的执行结果返回

可以通过返回值确定程序的执行走向

### 内部类

#### 什么内部类

内部类就是定义在另外一个类内部的类，可以理解为是类的一个属性

#### 内部类的分类有哪些

- 静态内部类
- 成员内部类
- 局部内部类
- 匿名内部类

#### 内部类的优点

- 内部类可以访问创建它的外部类的属性，包括私有成员
- 内部类只能在外部类中可见，其它同包类不可见
- 内部类有效的实现了“多重继承”
- 方便回调

#### 内部类有哪些应用场景

- 一些多算法场合
- 解决非面向对象语句块
- 适当使用内部类，使得代码更加灵活和富有扩展性。
- 当某个类除了它的外部类，不再被其他的类使用时。

#### 局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final

因为属性的生命周期不一致

### 重写与重载

#### 构造器是否可被重写

构造器不能被继承，也就不能被重写，但是可以重载

#### 重载和重写的区别，重载的方法能否根据返回类型进行区分

方法的重载和重写都是多态的实现方式，前者是编译时重载，后者是运行时重载

不能根据返回值判断，只能根据参数的类型，个数判断

### 对象相等判断

#### ==和equals的区别是什么

== 判断的是地址是否相等，equals方法判断两个对象的内如是否相同

情况1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。

情况2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来两个对象的内容相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。

#### hashCode 与equals()

如果两个对象相等，则hashcode一定也是相同的

两个对象相等，对两个对象分别调用equals方法都返回true

两个对象有相同的hashcode值，它们也不一定是相等的

#### 对象的相等于指向他们的引用相等有区别吗

对象相等比较的是内容的相等，引用相等比较的是地址的相等

### 值传递

#### 当一个对象被当做参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递

值传递。Java 中方法的调用只支持值传递，当以个对象当做一个参数传到方法中的时候，参数的值就是对象的引用。对象的属性可以在被调用的过程中修改，但是不会影响调用方。

#### 为什么Java中只有值传递

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDAyMzk3Mi00ZWQyZjQ0NTlmN2MyYzkwLmpwZw?x-oss-process=image/format,png)

#### 值传递和引用传递有什么区别

值传递：指的是在方法调用时，传递的参数是按值的拷贝传递，传递的是值的拷贝，也就是说传递后就互不相关了。

引用传递：指的是在方法调用时，传递的参数是按引用进行传递，其实传递的引用的地址，也就是变量所对应的内存空间的地址。传递的是值的引用，也就是说传递前和传递后都指向同一个引用（也就是同一个内存空间）。
————————————————
版权声明：本文为CSDN博主「ThinkWon」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/ThinkWon/article/details/104390612

### Java包

#### JDK中常用的包有哪些

java.lang：基础类

java.util：集合类

java.io：输入输出流相关

java.nio：提升io性能

java.sql：数据库操作相关

java.net：网络编程相关

#### import java 和javax 有什么区别

本质上么有区别，javax是后扩展的一些基础方法，都是java API的包

## IO流

#### Java 中IO 流分为几种

- 按照流向分：可以分为输入流和输出流
- 按照操作单元分：字节流和字符流
- 按照流的角色划分：节点流和处理流

#### BIO，NIO，AIO 有什么区别

#### Files 的常用方法都有哪些

- Files. exists()：检测文件路径是否存在。
- Files. createFile()：创建文件。
- Files. createDirectory()：创建文件夹。
- Files. delete()：删除一个文件或目录。
- Files. copy()：复制文件。
- Files. move()：移动文件。
- Files. size()：查看文件个数。
- Files. read()：读取文件。
- Files. write()：写入文件。
  

## 反射

#### 什么是反射机制

Java 反射机制是在运行状态下，对于任意一个类，都能顾知道这个类色所有属性和方法，对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取信息或动态调用对象方法的功能是Java 的反射机制。

#### 反射机制的优缺点

- 优点：运行期类型的潘丹，动态加载类，提高代码的灵活度
- 缺点：性能比直接的Java 代码慢。

#### 反射机制的应用场景有哪些

框架

#### Java获取反射的三种方法

1.通过new对象实现反射机制 

2.通过路径实现反射机制 

3.通过类名实现反射机制

## 字符串

#### 字符型常量和字符串常量的区别

字符型常量‘’，字符串常量“”

字符型常量相当于一个整型的ASCII 值，字符串常量是一个地址

字符型常量占用一个字节，字符串常量可能有多个字符

#### 什么是字符串常量池

字符串常量池位于堆内存中，专门用于存储字符串常量，JVM在创建字符串对象的时候，会首先检查字符串常量池是否有这个对象，如果没有则创建，如果存在，则直接返回此对象的引用

#### String 是最基本的数据类型吗

不是，基础的数据类型只有8中，byte,int,short,long,float,char,double,boolean

#### String 有哪些特性

不可变性: String 是只读的，每次操作都需要新创建一个对象。

字符串常量池：在创建对象的时候会进行缓存，如果已经有了此对象，再次创建时会直接返回引用的地址。

#### String 为什么是不可变的

Java中如此规定String

```java
private final char[] value;
```

#### String 真的是不可变的吗

对，不可变

#### 是否可以继承String 类

String 类不能被继承，是用final 修饰的

#### String str = “i” 与String str = new String(“i”) 一样吗

不一样，前者会现在字符串常量区判断是否存在对象”i“,如果有，则直接饮用，如果不存在，则在常量区创建这个对象；后者对象创建在堆内存中，无论常量池是否存在都会创建新对象。

#### String s = new Stirng("xyz"); 创建了几个字符串对象

两个对象，一个是建立在字符串常量区的对象，一个是new 在内存上的对象

#### 如何将字符串反转

使用StirngBuilder 或StringBuffer 的reverse() 方法

#### 数组有没有length() 方法，String有没有length() 方法

数组是length() 方法，String 有length 属性

#### String 类的常用方法都有哪些

Indexof() ：获取字符串所在的位置

length(): 字符串的长度

substring(): 截取长度

toUpperCase(): 转换成小写字母

toLowerCase(): 转换成大写字母

equals(): 比较

#### 在使用HashMap 的时候，使用String 做key 有什么好处

String 是不可变的对象，HashMap 计算value位置的时候采用的是key 的hashCode,此时将String缓存了起来，查找更快

#### String 和StringBuffer、StringBuilder 的区别是什么？String 为什么是不可变的

String 是一个不可变得对象，private final char[] value，所以是一个不可变的对象，每次赋值都会生成一个新的对象。

StringBuffer 和StringBuilder 是可变的对象，可以直接使用append 方法进行操作，操作的是对象本身，其中StringBuffer是线程安全的，本身有线程安全的判断，StringBuilder 不是线程安全的。

使用位置：当在多线程环境的时候，同时访问一个相同的对象，有状态的改变，这是需要考虑多线程安全的条件，如果满足条件，建议使用StringBuffer,否则使用StringBuffer.

## 包装类相关

#### 自动装箱与拆箱

装箱：将基本数据类型自动转换成包装类

拆箱：将包装类自动转换成基本数据类型

#### int 和Integer 有什么区别

Java 是一门面向对象的语言，但是为了操作数据的方便，Java引入了8种基本的数据类型，每种数据类型都有对应的封装类，在Java5之后，实现类自动装箱和拆箱的功能。其中各种数据类型对应的封装类如下：

基础数据类型为：short ,bype,char,int,long,float,double,boolean
对应封装类为：Short,Byte,Character,Integer,Long,Float,Double,Boolean

#### Integer a = 127 与 Integer b = 127 相等吗

```java
public static void main(String[] args) {
    // int 类型的变量自动装箱和拆箱的范围是-128~127之间，
    // 在这个范围的数字不会新建对象会引用常量池中的I呢个让对象，
    // 在变量赋值为128的时候会生成两个新的对象
    Integer a = 127;
    Integer b = 127;
    Integer c = 128;
    Integer d = 128;

    System.out.println(a == b);// true
    System.out.println(c == d);// false
}
```